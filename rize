#!/bin/bash
set -e

# Configuration
IMAGE_NAME="${RIZE_IMAGE:-alienxp03/rize:latest}"
CONTAINER_HOME="/home/agent"
CLAUDE_CONFIG_DIR="/home/agent/.agents/claude"
MOUNT_DIR="/home/agent/mounts"

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

# Helper: Detect Host Info
HOST_UID=$(id -u)
HOST_GID=$(id -g)
HOST_OS=$(uname -s)

# Helper: Build Docker Flags
build_flags() {
    local flags=()
    local project_name=$(basename "$(pwd)" | tr -cd '[:alnum:]_.-')
    local project_dir="$project_name"
    if [ -n "${RIZE_WORKSPACE_DIR:-}" ]; then
        project_dir="$RIZE_WORKSPACE_DIR"
    elif [ "${RIZE_WORKSPACE_UNIQUE:-0}" = "1" ]; then
        local project_hash=""
        if command -v sha1sum >/dev/null 2>&1; then
            project_hash=$(printf "%s" "$(pwd)" | sha1sum | awk '{print $1}')
        else
            project_hash=$(printf "%s" "$(pwd)" | shasum | awk '{print $1}')
        fi
        project_dir="${project_name}-${project_hash:0:8}"
    fi

    # 1. Basic Identity & Environment
    flags=(
        "-e" "HOST_UID=$HOST_UID"
        "-e" "HOST_GID=$HOST_GID"
        "-e" "TERM=$TERM"
        "-e" "COLORTERM=$COLORTERM"
        "-e" "RIZE_PROJECT_NAME=$project_name"
        "-e" "RIZE_PROJECT_DIR=$project_dir"
        "-e" "RIZE_WORKSPACE_DIR=/workspace/$project_dir"
        "-e" "CLAUDE_CONFIG_DIR=$CLAUDE_CONFIG_DIR"
    )

    # 2. Main Workspace Mount
    # We mount into /workspace/<dir> for clarity and to avoid collisions.
    flags+=("-v" "$(pwd):/workspace/$project_dir")
    flags+=("-w" "/workspace/$project_dir")

    # 3. Docker Socket (DooD)
    if [ -S "/var/run/docker.sock" ]; then
        flags+=("-v" "/var/run/docker.sock:/var/run/docker.sock")
    fi

    # 4. SSH Agent Forwarding
    if [ -n "$SSH_AUTH_SOCK" ]; then
        if [ "$HOST_OS" = "Darwin" ]; then
             # Docker Desktop on Mac handles magical socket paths differently sometimes,
             # but mounting proper socket acts best for compatibility.
             # If the path is /private/..., we mount it directly.
             flags+=("-v" "$SSH_AUTH_SOCK:$SSH_AUTH_SOCK" "-e" "SSH_AUTH_SOCK=$SSH_AUTH_SOCK")
        else
             flags+=("-v" "$SSH_AUTH_SOCK:$SSH_AUTH_SOCK" "-e" "SSH_AUTH_SOCK=$SSH_AUTH_SOCK")
        fi
    fi

    # 5. Auto-Mounts (Configs)
    # Claude (global, persisted via Docker volume)
    claude_target_dir="${CLAUDE_CONFIG_DIR:-$CONTAINER_HOME/.claude}"
    flags+=(--mount "type=volume,source=rize-agents,target=/home/agent/.agents")
    # Claude shared folders from host (read/write)
    mkdir -p "$HOME/.claude/commands" "$HOME/.claude/agents" "$HOME/.claude/skills"
    flags+=("-v" "$HOME/.claude/commands:$claude_target_dir/commands")
    flags+=("-v" "$HOME/.claude/agents:$claude_target_dir/agents")
    flags+=("-v" "$HOME/.claude/skills:$claude_target_dir/skills")
     # OpenCode
    if [ -d "$HOME/.config/opencode" ]; then
        mkdir -p "$HOME/.config/opencode" # Ensure it exists? No, only mount if exists.
        flags+=("-v" "$HOME/.config/opencode:$CONTAINER_HOME/.config/opencode")
    fi
    # Netrc (Read-Only)
    if [ -f "$HOME/.netrc" ]; then
        flags+=("-v" "$HOME/.netrc:$CONTAINER_HOME/.netrc:ro")
    fi
    # GitConfig (Read-Only)
    if [ -f "$HOME/.gitconfig" ]; then
        flags+=("-v" "$HOME/.gitconfig:$CONTAINER_HOME/.gitconfig:ro")
    fi
    # Known Hosts (Read-Only)
    if [ -f "$HOME/.ssh/known_hosts" ]; then
        mkdir -p "$HOME/.ssh" # Ensure dir exists on host so we can mount file?
        # Actually we just mount the file. Docker will create dir inside if missing.
        flags+=("-v" "$HOME/.ssh/known_hosts:$CONTAINER_HOME/.ssh/known_hosts:ro")
    fi
    # .env (Read-Only)
    if [ -f "$HOME/.env" ]; then
        flags+=("-v" "$HOME/.env:$CONTAINER_HOME/.env:ro")
    fi

    # .rize (Persisted Data Directory)
    if [ ! -d "$HOME/.rize" ]; then
        mkdir -p "$HOME/.rize"
    fi
    # We mount the whole directory to avoid file-mount rename issues with zsh history
    flags+=("-v" "$HOME/.rize:$CONTAINER_HOME/.local/share/rize")

    printf "%s\n" "${flags[@]}"
}

ensure_image() {
    if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        echo -e "${BLUE}Image $IMAGE_NAME not found locally. Pulling...${NC}"
        docker pull "$IMAGE_NAME" || {
            echo -e "${YELLOW}Pull failed. Trying to build locally...${NC}"
            echo -e "${RED}Error: Local build not supported in client-only mode.${NC}"
            exit 1
        }
    fi
}

cmd_shell() {
    ensure_image
    local flags=($(build_flags))
    echo -e "${GREEN}Starting shell in $IMAGE_NAME...${NC}"
    docker run --rm -it "${flags[@]}" --entrypoint /usr/local/bin/entrypoint.sh "$IMAGE_NAME" /bin/zsh
}

cmd_agent() {
    local agent_cmd="$1"
    shift
    ensure_image
    local flags=($(build_flags))
    echo -e "${GREEN}Running $agent_cmd...${NC}"
    # We pass the command to the entrypoint
    docker run --rm -it "${flags[@]}" --entrypoint /usr/local/bin/entrypoint.sh "$IMAGE_NAME" "$agent_cmd" "$@"
}

cmd_exec() {
    ensure_image
    local flags=($(build_flags))
    echo -e "${GREEN}Running command...${NC}"
    docker run --rm -it "${flags[@]}" --entrypoint /usr/local/bin/entrypoint.sh "$IMAGE_NAME" "$@"
}

cmd_install() {
    local install_path="/usr/local/bin/rize"
    local install_dir
    install_dir="$(dirname "$install_path")"
    local src="${RIZE_INSTALL_SRC:-}"
    local tmp_src=""

    if [ -z "$src" ]; then
        if [ -f "$0" ] && [ "$(basename "$0")" = "rize" ]; then
            src="$0"
        else
            src="https://raw.githubusercontent.com/alienxp03/rize/refs/heads/master/rize"
        fi
    fi

    if [[ "$src" == http://* || "$src" == https://* ]]; then
        tmp_src="$(mktemp)"
        if command -v curl >/dev/null 2>&1; then
            curl -fsSL "$src" -o "$tmp_src"
        elif command -v wget >/dev/null 2>&1; then
            wget -qO "$tmp_src" "$src"
        else
            echo -e "${RED}Error: curl or wget is required to download $src.${NC}"
            exit 1
        fi
        src="$tmp_src"
    fi

    if [ -w "$install_dir" ]; then
        cp "$src" "$install_path"
        chmod +x "$install_path"
    elif command -v sudo >/dev/null 2>&1; then
        echo -e "${YELLOW}Installing to $install_path requires elevated permissions; sudo may prompt for your password.${NC}"
        sudo cp "$src" "$install_path"
        sudo chmod +x "$install_path"
    else
        echo -e "${RED}Error: $install_dir is not writable and sudo is not available.${NC}"
        exit 1
    fi

    echo -e "${GREEN}Installed rize to $install_path${NC}"

    if [ -n "$tmp_src" ]; then
        rm -f "$tmp_src"
    fi
}

cmd_help() {
    echo -e "${BLUE}Rize - Secure AI Agent Sandbox${NC}"
    echo "Usage: rize [command]"

    echo ""
    echo "Commands:"
    echo "  shell       Start interactive shell (zsh)"
    echo "  claude      Run Claude Code agent"
    echo "  codex       Run OpenAI Codex agent"
    echo "  opencode    Run OpenCode agent"
    echo "  gemini      Run Gemini agent (via opencode)"
    echo "  exec        Run a shell command directly"
    echo "  update      Pull latest image and update rize script"
    echo "  install     Install rize to /usr/local/bin"
    echo "  uninstall   Remove rize from /usr/local/bin"
    echo "  help        Show this help"
}

cmd_update() {
    echo -e "${BLUE}Updating image $IMAGE_NAME...${NC}"
    docker pull "$IMAGE_NAME" || {
        echo -e "${RED}Error: Failed to pull image $IMAGE_NAME.${NC}"
        exit 1
    }

    local update_src="${RIZE_INSTALL_SRC:-https://raw.githubusercontent.com/alienxp03/rize/refs/heads/master/rize}"
    echo -e "${BLUE}Updating rize script...${NC}"
    RIZE_INSTALL_SRC="$update_src" cmd_install
}

cmd_uninstall() {
    local uninstall_path="/usr/local/bin/rize"
    local prompt="This will remove Docker image ${IMAGE_NAME} and uninstall rize from ${uninstall_path}. Continue? [y/N] "

    if [ -t 0 ]; then
        read -r -p "$prompt" confirm
    else
        echo -e "${YELLOW}Non-interactive shell detected. Aborting uninstall.${NC}"
        echo -e "${YELLOW}${prompt}${NC}"
        return 1
    fi

    case "${confirm:-}" in
        [yY]|[yY][eE][sS])
            ;;
        *)
            echo -e "${YELLOW}Uninstall cancelled.${NC}"
            return 0
            ;;
    esac

    if command -v docker >/dev/null 2>&1; then
        if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
            echo -e "${BLUE}Removing image $IMAGE_NAME...${NC}"
            docker image rm -f "$IMAGE_NAME" >/dev/null 2>&1 || {
                echo -e "${YELLOW}Warning: Failed to remove image $IMAGE_NAME.${NC}"
            }
        fi
    else
        echo -e "${YELLOW}Warning: docker not found; skipping image removal.${NC}"
    fi

    if [ ! -e "$uninstall_path" ]; then
        echo -e "${YELLOW}rize not found at $uninstall_path${NC}"
        return 0
    fi

    if [ -w "$uninstall_path" ] || [ -w "$(dirname "$uninstall_path")" ]; then
        rm -f "$uninstall_path"
        echo -e "${GREEN}Uninstalled rize from $uninstall_path${NC}"
    elif command -v sudo >/dev/null 2>&1; then
        echo -e "${YELLOW}Removing $uninstall_path requires elevated permissions; sudo may prompt for your password.${NC}"
        sudo rm -f "$uninstall_path"
        echo -e "${GREEN}Uninstalled rize from $uninstall_path${NC}"
    else
        echo -e "${RED}Error: $uninstall_path is not writable and sudo is not available.${NC}"
        exit 1
    fi
}

# Main Dispatch
COMMAND="${1:-}"
if [ -z "$COMMAND" ]; then
    if [ -t 0 ]; then
        COMMAND="help"
    else
        COMMAND="install"
    fi
else
    shift
fi

case "$COMMAND" in
    shell)
        cmd_shell
        ;;
    claude)
        cmd_agent "claude" "--dangerously-skip-permissions" "$@"
        ;;
    zai)
        cmd_agent "env" \
            "ANTHROPIC_AUTH_TOKEN=$ZAI_API_KEY" \
            "ANTHROPIC_MODEL=glm-4.7" \
            "ANTHROPIC_BASE_URL=https://api.z.ai/api/anthropic" \
            "claude" "--dangerously-skip-permissions" "$@"
        ;;
    codex)
        cmd_agent "codex" "$@"
        ;;
    opencode)
        cmd_agent "opencode" "$@"
        ;;
    gemini)
        local gemini_model="${RIZE_GEMINI_MODEL:-gemini-pro}"
        # Assuming opencode handles gemini via model flag or similar,
        # or fall back to generic shell if no specific tool exists.
        # For now, mapping to opencode with a placeholder or just generic opencode env
        cmd_agent "opencode" "--model" "$gemini_model" "$@"
        ;;
    exec)
        cmd_exec "$@"
        ;;
    update)
        cmd_update
        ;;
    install)
        cmd_install
        ;;
    uninstall)
        cmd_uninstall
        ;;
    *)
        cmd_help
        ;;
esac
